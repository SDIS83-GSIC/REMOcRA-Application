package remocra.data

import org.locationtech.jts.geom.Point
import java.time.ZonedDateTime
import java.util.UUID

/**
 * Modèle minimal d'un PEI pour NexSIS (avec code structure)
 */
data class ModeleMinimalPeiForNexsisData(
    val codeStructure: String,
    override val peiId: UUID,
    override val peiNumeroComplet: String,
    override val natureCode: String,
    override val isDisponible: Boolean,
    override val geometrie: Point,
    override val codeInsee: String,
    override val communeLibelle: String,
    override val idGestion: String?,
    override val nomGest: String?,
    override val peiNumeroInterne: String,
    override val typeRD: String?,
    override val diametre: Int?,
    override val pibiDiametreCanalisation: Int?,
    override val natureLibelle: String?,
    override val natureDeci: String,
    override val site: String?,
    override val adresse: String,
    override val pibiPressionDynamique: Double?,
    override val pibiPression: Double?,
    override val pibiDebit: Int?,
    override val penaVolumeConstate: Int?,
    override val instantChangementDispo: ZonedDateTime?,
    override val dateMiseEnService: ZonedDateTime?,
    override val dateMiseAJour: ZonedDateTime?,
    override val dateDernierControleTechnique: ZonedDateTime?,
    override val dateDerniereRop: ZonedDateTime?,
    override val precision: String?,
    override val isNonConforme: Boolean?,
    override val isAccessibleHbe: Boolean?,
) : ModeleMinimalPeiData(
    peiId = peiId,
    peiNumeroComplet = peiNumeroComplet,
    natureCode = natureCode,
    isDisponible = isDisponible,
    geometrie = geometrie,
    codeInsee = codeInsee,
    communeLibelle = communeLibelle,
    idGestion = idGestion,
    nomGest = nomGest,
    peiNumeroInterne = peiNumeroInterne,
    typeRD = typeRD,
    diametre = diametre,
    pibiDiametreCanalisation = pibiDiametreCanalisation,
    natureLibelle = natureLibelle,
    natureDeci = natureDeci,
    site = site,
    adresse = adresse,
    pibiPressionDynamique = pibiPressionDynamique,
    pibiPression = pibiPression,
    pibiDebit = pibiDebit,
    penaVolumeConstate = penaVolumeConstate,
    instantChangementDispo = instantChangementDispo,
    dateMiseEnService = dateMiseEnService,
    dateMiseAJour = dateMiseAJour,
    dateDernierControleTechnique = dateDernierControleTechnique,
    dateDerniereRop = dateDerniereRop,
    precision = precision,
    isNonConforme = isNonConforme,
    isAccessibleHbe = isAccessibleHbe,
) {
    fun convertFormatNexsis() = ModeleMinimalPeiForNexsisJsonData(
        codeStructure = codeStructure,
        id = peiId,
        idSdis = peiNumeroComplet,
        typePei = natureCode,
        disponible = isDisponible,
        geometrie = geometrie,
        codeInsee = codeInsee,
        commune = communeLibelle,
        idGestion = idGestion,
        nomGest = nomGest,
        refTerr = peiNumeroInterne,
        typeRd = typeRD,
        diamPei = diametre,
        diamCana = pibiDiametreCanalisation,
        sourcePei = natureLibelle,
        statut = natureDeci,
        nomEtab = site,
        situation = adresse,
        pressDyn = pibiPressionDynamique,
        pressStat = pibiPression,
        debit = pibiDebit,
        volume = penaVolumeConstate,
        dateDispo = instantChangementDispo,
        dateMes = dateMiseEnService,
        dateMaj = dateMiseAJour,
        dateCt = dateDernierControleTechnique,
        dateRo = dateDerniereRop,
        prec = precision,
        nonConforme = isNonConforme,
        accessibleHbe = isAccessibleHbe,
    )
}

/**
 * Les JsonProperty ne sont pas bien pris en compte par Jackson, on crée donc manuellement la classe que Nexsis attend.
 */
data class ModeleMinimalPeiForNexsisJsonData(
    val codeStructure: String,
    val id: UUID,
    val idSdis: String,
    val typePei: String,
    val disponible: Boolean,
    val geometrie: Point,
    val codeInsee: String,
    val commune: String,
    val idGestion: String?,
    val nomGest: String?,
    val refTerr: String,
    val typeRd: String?,
    val diamPei: Int?,
    val diamCana: Int?,
    val sourcePei: String?,
    val statut: String,
    val nomEtab: String?,
    val situation: String,
    val pressDyn: Double?,
    val pressStat: Double?,
    val debit: Int?,
    val volume: Int?,
    val dateDispo: ZonedDateTime?,
    val dateMes: ZonedDateTime?,
    val dateMaj: ZonedDateTime?,
    val dateCt: ZonedDateTime?,
    val dateRo: ZonedDateTime?,
    val prec: String?,
    val nonConforme: Boolean?,
    val accessibleHbe: Boolean?,
)
